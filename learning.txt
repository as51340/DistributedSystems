lGoogle RPC
- problems with JavaRMI: doesn't acknowledge heterogeneity, transparency is very
important for them but that can promote ignorance: network failures, bandwidh and latency, performance
SOAP/REST
- text based protocols, parsing is slow, size overhead, we don't have support for streaming
- exposoure to the transport protocol(HTTP)
gRPC
- no remote objects
- services and messages as part of IDL
- corase grained interfaces
- strong separation of concerns
- concentrated set of responsibilities
- fast: HTTP2 is much faster than HTTP1.1 - more robust protocol
- one-of fields - only one can be set at the time, all field share memory, others are automatically cleaned
- typically for internal service API's 
- languange(IDL) and platform independent
- theoretically it can be used also with JSON not protocol buffers
- after you write your proto file this can be used in any of supported languages
- efficient serialization, simple IDL, easy interface updating
- java_package: package we want to use for our generated Java classes
- 4 rpc methods inside our service definition
  - simple RPC - clients sends a request to the server using the stub and waits for a response to come back
  - server-side streaming - server returns a stream of messages back to the client
  - client-side streaming - clients writes a sequence of messages and server then reads them all
  - bidirectional streaming - order is always preserved but combination it's used between server and client is not specified, it can be any 
- basically protocol buffers and gRPC are separate but gRPC works very well with buffers - 
- concretly : JavaSerialization has some problems, XML is space intensive and it is hard to navigate DOM tree. Proto buffers - very efficient way to communicate between services.
Downsides
- IDL compiler - extra build step which can go wrong
- language support is required - not all languages have it

Introduction
- gRPC protoc compiler which compiles IDL to generate language specific code for skeletons(client and server)
- we want to minimize coupling between the generated communication channel and business logic




HTTP/2 features
- server anticipates requests - pushes resources before to the client - client still has authority to deny the server push
- concept of multiplexing - interleaving requests and responses - all over single TCP connection
- uses binary format - binary framing layer divides the message into frames that are segregated by their type - Data or Header - increases efficiency in terms of security, compression and multiplexing
- HPACK header compression algorithm - resilient to CRIME attacks and utilizies static Huffman encoding
- much more reliable than HTTP/1.1

Protocol buffers
- binary interchange format
- compact encoding
- language and platform neutral for serializing structured data
- small, fast and simple
- it's not possible to probe gRPC API's because they are binary interchange format!

Message streaming 
- constant input data coming


Questions:
1. What is streaming in web app? Constant input data coming
2. What is RPC declaration in protocol buffers' services?
3. In lab which classes are skeleton classes?
4. REST vs gRPC?
5. Can we use synchronous stub on streams - server-side or client-side?


Lab
- AlmaClientApp has reference to the AlmaOnlineClientAdapter and that is the interface which returns us default Script will be run as part of the testing job.
- after the service base class is generated from service definition we need to override it to actually implement some stuff
- we need to run a gRPC server to listen for requests from clients
- onNext() and onCompleted() behave differently if we have a stream of client or server messages
- onCompleted() - we specify that we've finished dealing with the RPC
- we have two types of stub - synchronous and asynchronous
- gROC channel - server address and port we want to connect
- REST vs SOAP - REST APIs are lighter and easier to understand
- external API - designed for partners and third-party developers
- internal API - within Line of Business(LOB) - e.g. usage by several companies
- syntac = "proto3" has to be specified
- field in the message definition has a unique number - specify smaller number
because it will take less bytes - some unique numbers are reserved for the
Protocol Buffers implementation
- message fields can be singular or repeated - 0 or 1 / 0 or as much as you want
- you can have more messages in same .proto file
- protoc - getters, setters, parsing messages from input stream and serializing to output stream
- specially for Java, compiler generate .java class for each message + Builder classes for creating message class instances
- java settings - where to generate files, name of the Java file and to create more files not only one 
- here it was already used to create those files?
- difference between Asynchronous and Future stub is that Future stub doesn't support streaming


AlmaOnlineClientAdapter - I should implement it to run the application
- client and service package have basically same classes but in this way we increase cohesion of the client and reduce coupling between the client and the server.

We are missing AlmaOnlineGrpc






















\documentclass{ds-report}

\assignment{--} % Set to `Remote communication` or `Project`.
\authorOne{Andi Å krgat} % Name of first team partner.
\studentnumberOne{r0876363} % Student number of first team partner.
\authorTwo{Team Partner } % Name of second team partner.
\studentnumberTwo{r1234567}  % Student number of second team partner.

\begin{document}
	\maketitle

	\paragraph{What is the role of stub and skeleton in Java RMI? Do the other remote communication technologies	have similar concepts? \newline}
	What is the role of stub and skeleton in Java RMI? Do the other remote communication technologies have similar concepts?
	Stub is an object which resides on client side. It acts as gateway for all outgoing requests from client. Stub first initiates a connection with 
	remote Virtual Machine and after that marshals the parameters to the remote Virtual Machine. Then it waits for the result, unmarshals the return
	value or exception and returns result to the caller. Skeleton in Java RMI is object which reads parameters for some remote method, calls method on
	remote object and later marshals the result to the caller. Sun RPC also uses stub functions, client stub on client side and server stub on server side.
	Their functionalities are same as in Java RMI(marhsaling, creating packages for transferring over the networkin and unamarshaling) with the difference that server stub executes a local procedure call to the actual server function.
	In CORBA a stub is a mechanism which issues requests as a client and skeleton delivers them to the CORBA object implementation. Based on these examples
	we can say some remote communication technology always has to have some similar mechanism for communication between client and server.
	
	
	
	\paragraph{2. What is the difference between serializable and remote? In your Java RMI assignment, which classes were made serializable and which classes were made remote? Motivate your choice. \newline}
	First difference is that Remote is class and Serializable is interface. Remote interface serves to identify which methods can be called from a non
	local machine. Only methods from object which extended Remote class are visible and can be accessed remotely. Serializable is used for all objects
	which are transferred as arguments from client to server or as a result from server to client. Serializable is only BookingDetail because this is 
	the only class whose instance is transferred as argument in addBooking method. IBookingManager is Remote so it "publishes" its methods to the outside.
	Every method from object which extends Remote must throw RemoteException. In Java RMI all primitive types and all serializable objects are passed
	by value while remote objects are passed by reference.
	
	
	
	\paragraph{3. What role does the RMI registry plays? Why is there no registry in the other remote communication technologies? \newline}
	RMI registry is the binder for Java RMI and it is used as name service. It stores mappings between names and references to remote objects which
	are hosted on compute. RMI registry must be run on server. There are two main methods for registering: bind and rebind and the only difference is
	that rebind can be called even if there is an object mapped to concrete name. Clients then need to use lookup function from Registry so they would be
	able to call right method from object registered on RMI registry. Other remote techonologies don't use naming registry because they 
	work differently. For example gRPC searches for IP address.
	
	\paragraph{4. Which concepts and configuration do you find in the WSDL in addition to what you specified in the meals.xsd? What is the SOAP binding style and transport configuration?}
	Messages are part of WSDL which are used to define what kind of messages can
	be received or sent and are consisted of different parts where each part is defined by a type. Types can be found in our meals.xsd schema: 1. complexType which contains other complex or
 	primitive types and 2. primitive type like: int, string, float... Another XML element which is in WSDL and not in our created schema is portType which defines interface and that is actually
 	the set of operations offered by one or more endpoints where each operation consists of input/output messages. Binding is used to tell us how above mentioned portType is bound to transport
 	protocol. Binding element then contains informations which transport protocol is used and additional informations which are specific to it. WSDL SOAP binding can be RPC style or document style
 	binding and both can have encoded or literal use. Both communication style models are used to translate WSDL binding to a SOAP message body. With document style SOAP body can be 
	structured in any way as long as the content of the SOAP message is valid XML. RPC style implies that SOAP request body contains operation name and the set of method parameters. With literal 
	use model body contents should follow what is written in user-defined schema and in this way we can easily validate the message body and transform the message using e.g XSLT transformation
	language. Encoded use model allows us to write messages which use XSD datatypes and it's not connected to any user-defined schema. Transport configuration is set to
	"http://schemas.xmlsoap.org/soap/http" which means that http is used as transport protocol. Some other URIs can indicate other transports for example SMTP, FTP...
	
	\clearpage
	
	% You can include diagrams here.
	
\end{document}
